\# Quad HW-Threaded ARM-Compatible Processor Core



\## ðŸ“Œ Project Overview

\[cite\_start]This project involves the design and implementation of a \*\*5-stage pipelined processor\*\* compatible with a subset of the \*\*ARM Instruction Set Architecture (ISA)\*\*\[cite: 3, 5, 61]. \[cite\_start]The core is synthesized on a \*\*NetFPGA\*\* platform and features hardware-level support for \*\*four independent threads\*\* with zero-overhead context switching\[cite: 7, 68].



---



\## ðŸ›  Instruction Set Implementation (ISA \& Opcode)



The primary challenge was bridging the gap between high-level C code and hardware. \[cite\_start]I implemented a processor datapath specifically designed to handle the opcodes generated by the \*\*ARM C compiler\*\*\[cite: 5, 38].



\### 1. Mapping Assembly to Hardware

\[cite\_start]I analyzed the `.s` (Assembly) files generated from `sort.c` to identify the required instruction subset\[cite: 27, 28, 42]:

\* \[cite\_start]\*\*ALU Operations:\*\* Implemented hardware logic for `ADD`, `SUB`, `LSL`, and `CMP` to handle arithmetic and comparison\[cite: 6, 43].

\* \[cite\_start]\*\*Data Transfer:\*\* Integrated `LDR` (Load) and `STR` (Store) instructions to interface with the Data Memory\[cite: 6, 43].

\* \[cite\_start]\*\*Control Flow:\*\* Implemented branch instructions like `B`, `BLE`, and `BGE` for loop execution and conditional logic\[cite: 6, 43].





\### 2. Instruction Decoding \& Execution

\* \[cite\_start]\*\*Decoding Stage (ID):\*\* The hardware decodes the 32-bit machine code to extract opcodes and register addresses\[cite: 37, 39].

\* \[cite\_start]\*\*Execution Stage (EX):\*\* The ALU performs operations based on the decoded control signals\[cite: 63].

\* \[cite\_start]\*\*Memory Stage (MEM):\*\* Handles data access for array sorting based on `LDR/STR` opcodes\[cite: 4, 6].



---



\## ðŸš€ Key Hardware Features



\### 1. Pipelined Architecture

\* \[cite\_start]\*\*5-Stage Datapath:\*\* IF (Fetch), ID (Decode), EX (Execute), MEM (Memory), and WB (Write Back)\[cite: 61, 65].

\* \[cite\_start]\*\*Modified Datapath:\*\* Added ALU controllers and components to execute the generated sort program\[cite: 62, 63].





\### 2. Zero-Overhead Multithreading

\* \[cite\_start]\*\*Quad-Thread Support:\*\* Integrated four sets of \*\*Program Counters (PC0-PC3)\*\* and \*\*Register Files (RF0-RF3)\*\*\[cite: 69].

\* \[cite\_start]\*\*Block Memory Implementation:\*\* Used a single block-memory for register files, utilizing the upper 2 bits of the address as a thread selector\[cite: 70, 71].

\* \[cite\_start]\*\*Double-Clocking:\*\* Implemented double-clocked memory access to support multiple read/write ports within a single cycle\[cite: 72].





---



\## ðŸ“‚ Project Structure

\* \[cite\_start]`/src`: Verilog source files for the processor core and multithreading logic\[cite: 123].

\* \[cite\_start]`/software`: C programs (including `sort.c`) and their corresponding `.s` assembly files\[cite: 8, 126].

\* \[cite\_start]`/docs`: Schematics, datapath diagrams, and final report\[cite: 121, 122].



---



\## âœ… Results \& Verification

\* \[cite\_start]\*\*Bubble Sort:\*\* Successfully sorted 10 random numbers in data memory, verified via internal memory dumps\[cite: 10, 128].

\* \[cite\_start]\*\*Multithreaded Performance:\*\* Demonstrated four parallel network packet-processing threads running on a single core\[cite: 114, 116].

